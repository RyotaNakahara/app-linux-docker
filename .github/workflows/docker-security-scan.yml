name: Docker Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # 毎週月曜日の午前2時（UTC）に実行
    - cron: '0 2 * * 1'

jobs:
  trivy-scan:
    name: Trivy Security Scan
    runs-on: ubuntu-latest

    permissions:
      contents: read
      security-events: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          tags: laravel-app:${{ github.sha }}
          push: false
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'laravel-app:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Trivy vulnerability scanner (table format)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'laravel-app:${{ github.sha }}'
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
          exit-code: '0'  # 脆弱性があっても失敗しない（警告のみ）

  docker-lint:
    name: Dockerfile Lint
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          failure-threshold: error  # warningは無視してerrorのみ失敗させる

  docker-build-test:
    name: Docker Build Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file
        run: |
          cp .env.example .env || cat > .env << 'EOF'
          APP_NAME=Laravel
          APP_ENV=local
          APP_KEY=
          APP_DEBUG=true
          APP_TIMEZONE=UTC
          APP_URL=http://localhost

          DB_CONNECTION=pgsql
          DB_HOST=postgres
          DB_PORT=5432
          DB_DATABASE=laravel
          DB_USERNAME=laravel
          DB_PASSWORD=secret

          REDIS_HOST=redis
          REDIS_PORT=6379
          REDIS_PASSWORD=

          SESSION_DRIVER=redis
          CACHE_STORE=redis

          MAIL_MAILER=smtp
          MAIL_HOST=mailhog
          MAIL_PORT=1025
          MAIL_USERNAME=null
          MAIL_PASSWORD=null
          MAIL_ENCRYPTION=null
          MAIL_FROM_ADDRESS=hello@example.com
          MAIL_FROM_NAME=Laravel
          EOF

      - name: Build and test
        run: |
          set -e  # エラーで即座に停止

          echo "Building Docker images..."
          docker compose build

          echo "Starting containers..."
          docker compose up -d

          # PostgreSQLとRedisのヘルスチェックを待つ
          echo "Waiting for database and cache to be ready..."
          for i in {1..30}; do
            postgres_healthy=$(docker compose ps postgres | grep -c "(healthy)" || echo "0")
            redis_healthy=$(docker compose ps redis | grep -c "(healthy)" || echo "0")

            if [ "$postgres_healthy" -ge 1 ] && [ "$redis_healthy" -ge 1 ]; then
              echo "✓ Dependencies are ready"
              break
            fi
            echo "Waiting for dependencies... ($i/30)"
            sleep 3
          done

          # 追加で10秒待機
          sleep 10

          # コンテナの状態を確認
          echo "=== Container Status ==="
          docker compose ps

          # APP_KEYを生成（リトライ機能付き）
          echo "Generating application key..."
          key_generated=false
          for i in {1..10}; do
            if docker compose exec -T app php artisan key:generate --force 2>&1 | grep -q "Application key set"; then
              echo "✓ APP_KEY generated successfully"
              key_generated=true
              break
            fi
            echo "⚠ Attempt $i/10 failed, retrying in 3s..."
            sleep 3
          done

          if [ "$key_generated" = false ]; then
            echo "✗ Failed to generate APP_KEY"
            docker compose logs app --tail=50
            exit 1
          fi

          # .envファイルにAPP_KEYが設定されたか確認
          docker compose exec -T app grep "APP_KEY=" .env | head -1

          # コンテナを再起動して環境変数を反映
          echo "Restarting containers to apply APP_KEY..."
          docker compose restart app nginx

          # 再起動後、十分に待機
          echo "Waiting for containers to restart..."
          sleep 20

          # ヘルスチェックが完了するまで待機
          echo "Waiting for all services to be healthy..."
          for i in {1..30}; do
            healthy_count=$(docker compose ps | grep -c "(healthy)" || echo "0")
            if [ "$healthy_count" -ge 3 ]; then
              echo "✓ At least 3 services are healthy!"
              break
            fi
            echo "Waiting for health checks... ($healthy_count healthy, attempt $i/30)"
            sleep 5
          done

          # 最終状態を表示
          echo "=== Final Container Status ==="
          docker compose ps
          echo "=== Recent Logs ==="
          docker compose logs --tail=30

      - name: Check app health
        run: |
          set -e  # エラーで即座に停止（最後のexitまで）

          echo "=== Final Container Status Before Health Check ==="
          docker compose ps

          # 追加で10秒待機
          echo "Waiting 10 seconds before health checks..."
          sleep 10

          # Nginxのヘルスチェックエンドポイントを確認（リトライ付き）
          echo "Testing /health endpoint..."
          health_success=false
          for i in {1..10}; do
            response=$(curl -s -o /tmp/health.txt -w "%{http_code}" http://localhost/health 2>&1 || echo "000")
            if [ "$response" = "200" ]; then
              echo "✓ Health endpoint OK (HTTP $response)"
              cat /tmp/health.txt 2>/dev/null || true
              echo ""
              health_success=true
              break
            fi
            echo "⚠ Attempt $i/10: HTTP $response, retrying in 5s..."
            sleep 5
          done

          # アプリケーションのルートを確認（リトライ付き）
          echo "Testing / endpoint..."
          root_success=false
          for i in {1..10}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/ 2>&1 || echo "000")
            if [ "$response" = "200" ]; then
              echo "✓ Root endpoint OK (HTTP $response)"
              root_success=true
              break
            fi
            echo "⚠ Attempt $i/10: HTTP $response, retrying in 5s..."

            # デバッグ: エラー詳細を表示
            if [ $i -eq 5 ]; then
              echo "=== Debug: Container Status at attempt 5 ==="
              docker compose ps
              echo "=== Debug: Nginx Error Log ==="
              docker compose logs nginx --tail=20
              echo "=== Debug: App Error Log ==="
              docker compose logs app --tail=20
            fi

            sleep 5
          done

          # 結果を確認
          echo ""
          echo "=== Health Check Results ==="
          echo "Health endpoint: $health_success"
          echo "Root endpoint: $root_success"

          if [ "$health_success" = "true" ] && [ "$root_success" = "true" ]; then
            echo "✓ All health checks passed!"
            exit 0
          fi

          # 失敗した場合、詳細なログを表示
          echo ""
          echo "✗ Health check failed"
          echo "=== Final Container Status ==="
          docker compose ps
          echo "=== Nginx Logs (last 100 lines) ==="
          docker compose logs nginx --tail=100
          echo "=== App Logs (last 100 lines) ==="
          docker compose logs app --tail=100
          echo "=== PostgreSQL Status ==="
          docker compose ps postgres
          echo "=== Redis Status ==="
          docker compose ps redis
          exit 1

      - name: Cleanup
        if: always()
        run: docker compose down -v

